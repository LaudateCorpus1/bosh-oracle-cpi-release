// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VolumeAttachment A base object for all types of attachments between a storage volume and an instance.
// For specific details about iSCSI attachments, see
// [IScsiVolumeAttachment Reference](#/en/iaas/20160918/IScsiVolumeAttachment/).
//
// For general information about volume attachments, see
// [Overview of Block Volume Storage](/Content/Block/Concepts/overview.htm).
//
// swagger:discriminator VolumeAttachment attachmentType
type VolumeAttachment interface {
	runtime.Validatable

	// The type of volume attachment.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	AttachmentType() string
	SetAttachmentType(string)

	// The Availability Domain of an instance.
	//
	// Example: `Uocm:PHX-AD-1`
	//
	// Required: true
	// Max Length: 255
	// Min Length: 1
	AvailabilityDomain() *string
	SetAvailabilityDomain(*string)

	// The OCID of the compartment.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	CompartmentID() *string
	SetCompartmentID(*string)

	// A user-friendly name. Does not have to be unique, and it cannot be changed.
	// Avoid entering confidential information.
	//
	// Example: `My volume attachment`
	//
	// Max Length: 255
	// Min Length: 1
	DisplayName() string
	SetDisplayName(string)

	// The OCID of the volume attachment.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	ID() *string
	SetID(*string)

	// The OCID of the instance the volume is attached to.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	InstanceID() *string
	SetInstanceID(*string)

	// Whether the attachment was created in read-only mode.
	IsReadOnly() bool
	SetIsReadOnly(bool)

	// The current state of the volume attachment.
	// Required: true
	LifecycleState() *string
	SetLifecycleState(*string)

	// The date and time the volume was created, in the format defined by RFC3339.
	//
	// Example: `2016-08-25T21:10:29.600Z`
	//
	// Required: true
	TimeCreated() *strfmt.DateTime
	SetTimeCreated(*strfmt.DateTime)

	// The OCID of the volume.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	VolumeID() *string
	SetVolumeID(*string)
}

type volumeAttachment struct {
	attachmentTypeField string

	availabilityDomainField *string

	compartmentIdField *string

	displayNameField string

	idField *string

	instanceIdField *string

	isReadOnlyField bool

	lifecycleStateField *string

	timeCreatedField *strfmt.DateTime

	volumeIdField *string
}

func (m *volumeAttachment) AttachmentType() string {
	return "VolumeAttachment"
}
func (m *volumeAttachment) SetAttachmentType(val string) {

}

func (m *volumeAttachment) AvailabilityDomain() *string {
	return m.availabilityDomainField
}
func (m *volumeAttachment) SetAvailabilityDomain(val *string) {
	m.availabilityDomainField = val
}

func (m *volumeAttachment) CompartmentID() *string {
	return m.compartmentIdField
}
func (m *volumeAttachment) SetCompartmentID(val *string) {
	m.compartmentIdField = val
}

func (m *volumeAttachment) DisplayName() string {
	return m.displayNameField
}
func (m *volumeAttachment) SetDisplayName(val string) {
	m.displayNameField = val
}

func (m *volumeAttachment) ID() *string {
	return m.idField
}
func (m *volumeAttachment) SetID(val *string) {
	m.idField = val
}

func (m *volumeAttachment) InstanceID() *string {
	return m.instanceIdField
}
func (m *volumeAttachment) SetInstanceID(val *string) {
	m.instanceIdField = val
}

func (m *volumeAttachment) IsReadOnly() bool {
	return m.isReadOnlyField
}
func (m *volumeAttachment) SetIsReadOnly(val bool) {
	m.isReadOnlyField = val
}

func (m *volumeAttachment) LifecycleState() *string {
	return m.lifecycleStateField
}
func (m *volumeAttachment) SetLifecycleState(val *string) {
	m.lifecycleStateField = val
}

func (m *volumeAttachment) TimeCreated() *strfmt.DateTime {
	return m.timeCreatedField
}
func (m *volumeAttachment) SetTimeCreated(val *strfmt.DateTime) {
	m.timeCreatedField = val
}

func (m *volumeAttachment) VolumeID() *string {
	return m.volumeIdField
}
func (m *volumeAttachment) SetVolumeID(val *string) {
	m.volumeIdField = val
}

// Validate validates this volume attachment
func (m *volumeAttachment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityDomain(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCompartmentID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateInstanceID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeCreated(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVolumeID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *volumeAttachment) validateAvailabilityDomain(formats strfmt.Registry) error {

	if err := validate.Required("availabilityDomain", "body", m.AvailabilityDomain()); err != nil {
		return err
	}

	if err := validate.MinLength("availabilityDomain", "body", string(*m.AvailabilityDomain()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("availabilityDomain", "body", string(*m.AvailabilityDomain()), 255); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateCompartmentID(formats strfmt.Registry) error {

	if err := validate.Required("compartmentId", "body", m.CompartmentID()); err != nil {
		return err
	}

	if err := validate.MinLength("compartmentId", "body", string(*m.CompartmentID()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("compartmentId", "body", string(*m.CompartmentID()), 255); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateDisplayName(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayName()) { // not required
		return nil
	}

	if err := validate.MinLength("displayName", "body", string(m.DisplayName()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("displayName", "body", string(m.DisplayName()), 255); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID()); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", string(*m.ID()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(*m.ID()), 255); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateInstanceID(formats strfmt.Registry) error {

	if err := validate.Required("instanceId", "body", m.InstanceID()); err != nil {
		return err
	}

	if err := validate.MinLength("instanceId", "body", string(*m.InstanceID()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("instanceId", "body", string(*m.InstanceID()), 255); err != nil {
		return err
	}

	return nil
}

var volumeAttachmentTypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ATTACHING","ATTACHED","DETACHING","DETACHED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeAttachmentTypeLifecycleStatePropEnum = append(volumeAttachmentTypeLifecycleStatePropEnum, v)
	}
}

const (

	// VolumeAttachmentLifecycleStateATTACHING captures enum value "ATTACHING"
	VolumeAttachmentLifecycleStateATTACHING string = "ATTACHING"

	// VolumeAttachmentLifecycleStateATTACHED captures enum value "ATTACHED"
	VolumeAttachmentLifecycleStateATTACHED string = "ATTACHED"

	// VolumeAttachmentLifecycleStateDETACHING captures enum value "DETACHING"
	VolumeAttachmentLifecycleStateDETACHING string = "DETACHING"

	// VolumeAttachmentLifecycleStateDETACHED captures enum value "DETACHED"
	VolumeAttachmentLifecycleStateDETACHED string = "DETACHED"
)

// prop value enum
func (m *volumeAttachment) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, volumeAttachmentTypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *volumeAttachment) validateLifecycleState(formats strfmt.Registry) error {

	if err := validate.Required("lifecycleState", "body", m.LifecycleState()); err != nil {
		return err
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycleState", "body", *m.LifecycleState()); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateTimeCreated(formats strfmt.Registry) error {

	if err := validate.Required("timeCreated", "body", m.TimeCreated()); err != nil {
		return err
	}

	if err := validate.FormatOf("timeCreated", "body", "date-time", m.TimeCreated().String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *volumeAttachment) validateVolumeID(formats strfmt.Registry) error {

	if err := validate.Required("volumeId", "body", m.VolumeID()); err != nil {
		return err
	}

	if err := validate.MinLength("volumeId", "body", string(*m.VolumeID()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("volumeId", "body", string(*m.VolumeID()), 255); err != nil {
		return err
	}

	return nil
}

// UnmarshalVolumeAttachmentSlice unmarshals polymorphic slices of VolumeAttachment
func UnmarshalVolumeAttachmentSlice(reader io.Reader, consumer runtime.Consumer) ([]VolumeAttachment, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []VolumeAttachment
	for _, element := range elements {
		obj, err := unmarshalVolumeAttachment(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalVolumeAttachment unmarshals polymorphic VolumeAttachment
func UnmarshalVolumeAttachment(reader io.Reader, consumer runtime.Consumer) (VolumeAttachment, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalVolumeAttachment(data, consumer)
}

func unmarshalVolumeAttachment(data []byte, consumer runtime.Consumer) (VolumeAttachment, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the attachmentType property.
	var getType struct {
		AttachmentType string `json:"attachmentType"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("attachmentType", "body", getType.AttachmentType); err != nil {
		return nil, err
	}

	// The value of attachmentType is used to determine which type to create and unmarshal the data into
	switch getType.AttachmentType {
	case DiscriminatorTypeValues["IScsiVolumeAttachment"]:
		var result IScsiVolumeAttachment
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "VolumeAttachment":
		var result volumeAttachment
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid attachmentType value: %q", getType.AttachmentType)

}
